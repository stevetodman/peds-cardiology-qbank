# Developer Guide for the Gamified Congenital Heart Disease Learning Platform

This document explains how to work with the lightweight codebase that powers the gamified congenital heart disease (CHD) study tool. The project provides a static documentation site (generated by the existing HTML/CSS/JS files) and a self-contained Python backend that exposes quiz, scoring, and leaderboard functionality without requiring external dependencies. The backend persists data to a JSON file, making it runnable in offline or firewalled environments.

The guide focuses on the pieces that exist in this repository today and offers recommendations for scaling toward the long-term vision of a Django/React/PostgreSQL deployment when network access is available.

---

## 1. Platform Overview

### Functional Highlights
- **Learning objectives & questions** – Questions are grouped by objective and delivered in randomized ten-question quizzes.
- **Immediate feedback** – Responses are scored instantly with explanations for every item.
- **Gamification** – Points (10 per correct answer), badges (≥80% accuracy per objective), levels (`points // 100 + 1`), and a leaderboard keep students motivated.
- **Progress tracking** – User profiles capture per-objective performance and badges.
- **Low-friction setup** – All backend capabilities run on the Python standard library; no third-party package installation is required.

### Current Technology Stack
| Layer        | Technology                       | Notes |
| ------------ | -------------------------------- | ----- |
| Backend API  | Python 3 standard library        | `http.server`, JSON persistence, custom logic in `backend/` |
| Data store   | JSON file (`backend/database.json`) | File-based store managed by `backend/storage.py` |
| Frontend     | Static HTML/CSS/JS               | Optimized via `npm run build` pipeline; interacts with API via fetch/axios (to be integrated) |

For teams planning to scale the platform, the architecture cleanly separates the backend logic so you can later replace the JSON database with PostgreSQL and swap `http.server` for Django REST Framework without rewriting the quiz and gamification rules.

---

## 2. Repository Layout

```
peds-cardiology-qbank/
├── backend/
│   ├── __init__.py              # Marks package for absolute imports
│   ├── manage.py                # CLI helper: check, seed, runserver
│   ├── sample_data.py           # Bundled objectives and questions
│   ├── security.py              # Password hashing and session tokens
│   ├── server.py                # HTTP API built on http.server
│   ├── service.py               # Domain logic for quizzes & scoring
│   └── storage.py               # JSON persistence utilities
├── build.js / package.json      # Frontend build pipeline
├── index.html, script.js, styles.css
├── README.md, USER_GUIDE.md     # High-level documentation
└── STATUS_REPORT.md             # Project status and roadmap
```

The `backend/database.json` file is generated on demand and excluded from version control via `.gitignore`.

---

## 3. Environment Setup

Only Python 3.11+ and Node.js 18+ are required. No package downloads are necessary for the backend.

### Backend Quick Start
```bash
# 1. Run the demo workflow (seeds bundled data and starts the server)
python backend/manage.py demo

# 2. Validate the storage schema and content integrity
python backend/manage.py check

# 3. (Optional) Run the HTTP API without reseeding
python backend/manage.py runserver
```

All commands accept `--database /path/to/file.json` if you prefer a custom storage location. The default is `backend/database.json`.

### Frontend Build
The static documentation already works in any browser. When you modify the frontend assets, run:
```bash
npm install      # first run only
npm run build    # outputs optimized files in dist/
```
The build script simply minifies `index.html`, `script.js`, and `styles.css` and copies them to `dist/`.

---

## 4. Backend Architecture

The backend is broken into focused modules so the core logic remains portable.

### `storage.py`
- Defines a `Database` class that loads/saves a JSON dictionary while guaranteeing required keys (`objectives`, `questions`, `users`, `leaderboard`, `sessions`).
- Provides `Database.default()` for the canonical file path and `wipe_and_seed()` to replace the current state with bundled data.
- Deduplicates leaderboard entries and ensures questions always reference an existing objective.

### `sample_data.py`
- Supplies two learning objectives and four exemplar questions used for demos and tests.
- Seeds a placeholder “demo” user with zero points so the leaderboard renders immediately.

### `security.py`
- Implements PBKDF2-HMAC password hashing using only the standard library.
- Generates cryptographically secure session tokens for login sessions.

### `service.py`
- Houses all business rules (registration, login, quiz generation, grading, badge/level updates, leaderboard sync, and profile retrieval).
- Exposes clear functions (`register_user`, `login_user`, `list_objectives`, `generate_quiz`, `grade_quiz`, `leaderboard`, `current_profile`) that can be reused by alternative frontends or future frameworks.
- Keeps authorization simple: endpoints expect a `Bearer <token>` header obtained from `login_user`.

### `server.py`
- Wraps the service layer in a `ThreadingHTTPServer` so multiple requests can be handled concurrently.
- Routes:
  - `GET /api/objectives` – list objectives with question counts.
  - `GET /api/objectives/<id>/quiz` – fetch randomized quiz questions (without answers).
  - `POST /api/objectives/<id>/quiz` – grade submissions; requires `Authorization: Bearer <token>` header.
  - `GET /api/leaderboard` – current rankings.
  - `POST /api/auth/register` – create account.
  - `POST /api/auth/login` – authenticate and receive session token.
  - `GET /api/profile` – authenticated user profile.
- Provides permissive CORS headers so the static frontend or external tools can call the API.

### `manage.py`
- Supplies four commands: `check`, `seed`, `runserver`, and the new `demo` helper that seeds and serves in one step.
- Works whether invoked as `python backend/manage.py check` or `python -m backend.manage check` thanks to path bootstrapping logic.

---

## 5. Data Model & Gamification Rules

| Entity     | Fields |
| ---------- | ------ |
| Learning Objective | `id`, `name`, `description`, derived `question_count` |
| Question   | `id`, `objective_id`, `text`, `options` (`A`–`D`), `correct_answer`, `explanation` |
| User Profile | `password_hash`, `salt`, `points`, `badges`, `level`, `completed_objectives` (per-objective stats) |
| Leaderboard Entry | `username`, `total_points`, `updated_at` |
| Session    | `token`, `username`, `created_at` |

Scoring logic resides in `service.grade_quiz`:
- Compares submitted answers with stored answers.
- Awards `10` points per correct response; levels increment each 100 points.
- Accuracy ≥ 0.8 adds a `<Objective Name> Master` badge (only once per objective).
- Leaderboard updates atomically with the profile.

Because JSON persistence is human-readable, you can inspect or edit `backend/database.json` between runs for quick experiments.

---

## 6. Testing & Diagnostics

- `python backend/manage.py check` – ensures the JSON schema matches expectations, validates question/objective relationships, and prints the number of available objectives.
- Unit-style tests can be added by importing the `service` functions into standard `unittest` modules; no frameworks are required.
- For manual API verification, use `curl` or REST clients:
  ```bash
  curl -X POST http://127.0.0.1:8000/api/auth/register \
       -H "Content-Type: application/json" \
       -d '{"username": "alice", "password": "securepass"}'
  ```

---

## 7. Deployment Notes

The current backend is intentionally simple and suited for prototypes or educational demos. To deploy:
1. Copy the repository to a host with Python 3 (no pip installs needed).
2. Seed the database (optional) and run `python backend/manage.py runserver --host 0.0.0.0 --port 8080`.
3. Serve the static frontend via any HTTP server (e.g., `python -m http.server` inside the project root or upload the `dist/` folder to a CDN).

### Path to the Long-Term Stack
When you are ready to graduate to the Django/React/PostgreSQL architecture outlined in early plans:
- Replace the JSON persistence layer with a relational database and migrate the service functions into Django REST Framework viewsets.
- Reuse `service.py` as a reference implementation for the scoring algorithms.
- Keep the public API surface similar so the frontend can remain unchanged while the backend gains enterprise features (RBAC, analytics, collaborative sessions, etc.).

---

## 8. Maintenance Tips

- Commit the JSON database only for fixtures; otherwise keep it gitignored to avoid leaking user data.
- Run `manage.py check` in CI to confirm migrations, seeds, or manual edits keep the schema valid.
- Document new objectives or question imports in `STATUS_REPORT.md` to maintain traceability.
- Consider writing smoke tests that call the HTTP endpoints once you connect the static frontend to the API.

---

## 9. Further Enhancements

- **Frontend integration** – Create React or vanilla JS modules that call the API endpoints and render live quizzes.
- **Analytics exports** – Extend `service.py` with CSV/JSON exporters for per-objective performance.
- **Collaborative modes** – Introduce shared session codes and group scoring logic in the service layer.
- **Content tooling** – Build import/export scripts (CSV → JSON) that leverage the `Database` abstraction.

With this structure, the project now “just works” even behind strict firewalls while providing a clean upgrade path to the fully managed stack described in the product vision.
